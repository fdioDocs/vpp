

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Infrastructure &mdash; Vector Packet Processor 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Network Stack Layer (src/vnet)" href="Network_Stack_Layer.html" />
    <link rel="prev" title="Overview" href="index.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Vector Packet Processor
          

          
            
            <img src="../../_static/fd-io_red_white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gettingstarted/index.html">Getting Started (Users)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usecases/index.html">Use Cases</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Getting Started (Developers)</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Overview</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Infrastructure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vppinfra">Vppinfra</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Network_Stack_Layer.html">Network Stack Layer (src/vnet)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Application_Shell.html">Application Shell (src/vpp)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Plug-ins.html">Plug-ins (src/plugins)</a></li>
<li class="toctree-l3"><a class="reference internal" href="featurearcs.html">Feature Arcs</a></li>
<li class="toctree-l3"><a class="reference internal" href="bihash.html">Bounded-index Extensible Hashing</a></li>
<li class="toctree-l3"><a class="reference internal" href="bihash.html#bihash-cookbook">Bihash Cookbook</a></li>
<li class="toctree-l3"><a class="reference internal" href="bihash.html#creating-a-new-template-instance">Creating a new template instance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting/index.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/index.html">User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Vector Packet Processor</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Getting Started (Developers)</a> &raquo;</li>
        
          <li><a href="index.html">Overview</a> &raquo;</li>
        
      <li>Infrastructure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/gstarteddevel/swarch/Infrastructure.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="toctree-wrapper compound">
</div>
<div class="section" id="infrastructure">
<h1>Infrastructure<a class="headerlink" href="#infrastructure" title="Permalink to this headline">¶</a></h1>
<p>The files for this function are located in the …/src/vnet folder. The Infrastructure layer contains the following sections:
* vppinfra
* vlib, vlibapi, vlibmemory
* svm</p>
<div class="section" id="vppinfra">
<h2>Vppinfra<a class="headerlink" href="#vppinfra" title="Permalink to this headline">¶</a></h2>
<p>Vppinfra section is a collection of basic c-library services, quite sufficient
to build standalone programs to run directly on bare metal. It also
provides high-performance dynamic arrays, hashes, bitmaps,
high-precision real-time clock support, fine-grained event-logging,
and data structure serialization.</p>
<p>One fair comment / fair warning about vppinfra: you can’t always tell
a macro from an inline function from an ordinary function simply by
name. Macros are used to avoid function calls in the typical case, and
to cause (intentional) side-effects.</p>
<p>Vppinfra has been around for almost 20 years and tends not to change frequently.</p>
<div class="section" id="vectors">
<h3>Vectors<a class="headerlink" href="#vectors" title="Permalink to this headline">¶</a></h3>
<p>Vppinfra vectors are ubiquitous dynamically resized arrays with by
user defined “headers”. Many vpppinfra data structures (e.g. hash,
heap, pool) are vectors with various different headers.</p>
<p>The memory layout looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                  <span class="n">User</span> <span class="n">header</span> <span class="p">(</span><span class="n">optional</span><span class="p">,</span> <span class="n">uword</span> <span class="n">aligned</span><span class="p">)</span>
                  <span class="n">Alignment</span> <span class="n">padding</span> <span class="p">(</span><span class="k">if</span> <span class="n">needed</span><span class="p">)</span>
                  <span class="n">Vector</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">elements</span>
<span class="n">User</span><span class="s1">&#39;s pointer -&gt; Vector element 0</span>
                  <span class="n">Vector</span> <span class="n">element</span> <span class="mi">1</span>
                  <span class="o">...</span>
                  <span class="n">Vector</span> <span class="n">element</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>As shown above, the vector APIs deal with pointers to the 0th element
of a vector. Null pointers are valid vectors of length zero.</p>
<p>To avoid thrashing the memory allocator, one often resets the length
of a vector to zero while retaining the memory allocation. Set the
vector length field to zero via the vec_reset_length(v) macro. [Use
the macro! It’s smart about NULL pointers.]</p>
<p>Typically, the user header is not present. User headers allow for
other data structures to be built atop vppinfra vectors.  Users may
specify the alignment for data elements via the vec_*_aligned macros.</p>
<p>Vectors elements can be any C type e.g. (int, double, struct
bar). This is also true for data types built atop vectors (e.g. heap,
pool, etc.).  Many macros have _a variants supporting alignment of
vector data and _h variants supporting non-zero-length vector
headers. The _ha variants support both.</p>
<p>Inconsistent usage of header and/or alignment related macro variants
will cause delayed, confusing failures.</p>
<p>Standard programming error: memorize a pointer to the ith element of a
vector, and then expand the vector. Vectors expand by 3/2, so such
code may appear to work for a period of time. Correct code almost
always memorizes vector <strong>indices</strong> which are invariant across
reallocations.</p>
<p>In typical application images, one supplies a set of global functions
designed to be called from gdb. Here are a few examples:</p>
<ul class="simple">
<li>vl(v) - prints vec_len(v)</li>
<li>pe(p) - prints pool_elts(p)</li>
<li>pifi(p, index) - prints pool_is_free_index(p, index)</li>
<li>debug_hex_bytes (p, nbytes) - hex memory dump nbytes starting at p</li>
</ul>
<p>Use the “show gdb” debug CLI command to print the current set.</p>
<div class="section" id="bitmaps">
<h4>Bitmaps<a class="headerlink" href="#bitmaps" title="Permalink to this headline">¶</a></h4>
<p>Vppinfra bitmaps are dynamic, built using the vppinfra vector
APIs. Quite handy for a variety jobs.</p>
</div>
<div class="section" id="pools">
<h4>Pools<a class="headerlink" href="#pools" title="Permalink to this headline">¶</a></h4>
<p>Vppinfra pools combine vectors and bitmaps to rapidly allocate and
free fixed-size data structures with independent lifetimes. Pools are
perfect for allocating per-session structures.</p>
</div>
<div class="section" id="hashes">
<h4>Hashes<a class="headerlink" href="#hashes" title="Permalink to this headline">¶</a></h4>
<p>Vppinfra provides several hash flavors. Data plane problems involving
packet classification / session lookup often use
…/src/vppinfra/bihash_template.[ch] bounded-index extensible
hashes. These templates are instantiated multiple times, to
efficiently service different fixed-key sizes.</p>
<p>Bihashes are thread-safe. Read-locking is not required. A simple
spin-lock ensures that only one thread writes an entry at a time.</p>
<p>The original vppinfra hash implementation in …/src/vppinfra/hash.[ch] are simple to use, and are often used in control-plane code which needs exact-string-matching.</p>
<p>In either case, one almost always looks up a key in a hash table to
obtain an index in a related vector or pool. The APIs are simple
enough, but one must take care when using the unmanaged
arbitrary-sized key variant. Hash_set_mem (hash_table, key_pointer,
value) memorizes key_pointer. It is usually a bad mistake to pass the
address of a vector element as the second argument to hash_set_mem. It
is perfectly fine to memorize constant string addresses in the text
segment.</p>
</div>
<div class="section" id="format">
<h4>Format<a class="headerlink" href="#format" title="Permalink to this headline">¶</a></h4>
<p>Vppinfra format is roughly equivalent to printf.</p>
<p>Format has a few properties worth mentioning. Format’s first argument
is a (u8 *) vector to which it appends the result of the current
format operation.  Chaining calls is very easy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u8</span> <span class="o">*</span> <span class="n">result</span><span class="p">;</span>

<span class="n">result</span> <span class="o">=</span> <span class="nb">format</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;junk = </span><span class="si">%d</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">junk</span><span class="p">);</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">format</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;more junk = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">more_junk</span><span class="p">);</span>
</pre></div>
</div>
<p>As previously noted, NULL pointers are perfectly proper 0-length
vectors. Format returns a (u8 *) vector, <strong>not</strong> a C-string. If you
wish to print a (u8 *) vector, use the “%v” format string. If you need
a (u8 *) vector which is also a proper C-string, either of these
schemes may be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vec_add1</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ow">or</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">format</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;&lt;whatever&gt;</span><span class="si">%c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Remember to vec_free() the result if appropriate. Be careful not to
pass format an uninitialized u8 *.</p>
<p>Format implements a particularly handy user-format scheme via the “%U”
format specification. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u8</span> <span class="o">*</span> <span class="n">format_junk</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">va_list</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">junk</span> <span class="o">=</span> <span class="n">va_arg</span> <span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">format</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">junk</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">result</span> <span class="o">=</span> <span class="nb">format</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;junk = %U, format_junk, &quot;</span><span class="n">This</span> <span class="ow">is</span> <span class="n">some</span> <span class="n">junk</span><span class="s2">&quot;);</span>
</pre></div>
</div>
<p>format_junk() can invoke other user-format functions if desired. The
programmer shoulders responsibility for argument type-checking. It is
typical for user format functions to blow up if the va_arg(va, &lt;type&gt;)
macros don’t match the caller’s idea of reality.</p>
</div>
<div class="section" id="unformat">
<h4>Unformat<a class="headerlink" href="#unformat" title="Permalink to this headline">¶</a></h4>
<p>Vppinfra unformat is vaguely related to scanf, but considerably more general.</p>
<p>A typical use case involves initializing an unformat_input_t from
either a C-string or a (u8 *) vector, then parsing via unformat() as
follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unformat_input_t</span> <span class="nb">input</span><span class="p">;</span>

<span class="n">unformat_init_string</span> <span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">,</span> <span class="s2">&quot;&lt;some-C-string&gt;&quot;</span><span class="p">);</span>
<span class="o">/*</span> <span class="ow">or</span> <span class="o">*/</span>
<span class="n">unformat_init_vector</span> <span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">u8</span><span class="o">-</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>Then loop parsing individual elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">unformat_check_input</span> <span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UNFORMAT_END_OF_INPUT</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">unformat</span> <span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">,</span> <span class="s2">&quot;value1 </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value1</span><span class="p">))</span>
    <span class="p">;</span><span class="o">/*</span> <span class="n">unformat</span> <span class="n">sets</span> <span class="n">value1</span> <span class="o">*/</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unformat</span> <span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">,</span> <span class="s2">&quot;value2 </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value2</span><span class="p">)</span>
    <span class="p">;</span><span class="o">/*</span> <span class="n">unformat</span> <span class="n">sets</span> <span class="n">value2</span> <span class="o">*/</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">clib_error_return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;unknown input &#39;%U&#39;&quot;</span><span class="p">,</span> <span class="n">format_unformat_error</span><span class="p">,</span>
                              <span class="nb">input</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As with format, unformat implements a user-unformat function
capability via a “%U” user unformat function scheme.</p>
</div>
<div class="section" id="vppinfra-errors-and-warnings">
<h4>Vppinfra errors and warnings<a class="headerlink" href="#vppinfra-errors-and-warnings" title="Permalink to this headline">¶</a></h4>
<p>Many functions within the vpp dataplane have return-values of type
clib_error_t *. Clib_error_t’ss are arbitrary strings with a
bit of metadata [fatal, warning] and are easy to announce. Returning
a NULL clib_error_t * indicates “A-OK, no error.”</p>
<p>Clib_warning(&lt;format-args&gt;) is a handy way to add debugging output;
clib warnings prepend function:line info to unambiguously locate the
message source.  Clib_unix_warning() adds perror()-style Linux
system-call information. In production images, clib_warnings result in
syslog entries.</p>
</div>
<div class="section" id="serialization">
<h4>Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">¶</a></h4>
<p>Vppinfra serialization support allows the programmer to easily serialize and unserialize complex data structures.</p>
<p>The underlying primitive serialize/unserialize functions use network
byte-order, so there are no structural issues serializing on a
little-endian host and unserializing on a big-endian host.</p>
</div>
<div class="section" id="event-logger-graphical-event-log-viewer">
<h4>Event-logger, graphical event log viewer<a class="headerlink" href="#event-logger-graphical-event-log-viewer" title="Permalink to this headline">¶</a></h4>
<p>The vppinfra event logger provides very lightweight (sub-100ns)
precisely time-stamped event-logging services. See
…/src/vppinfra/{elog.c, elog.h}</p>
<p>Serialization support makes it easy to save and ultimately to combine
a set of event logs. In a distributed system running NTP over a local
LAN, we find that event logs collected from multiple system elements
can be combined with a temporal uncertainty no worse than 50us.</p>
<p>A typical event definition and logging call looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ELOG_TYPE_DECLARE</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s2">&quot;tx-msg: stream </span><span class="si">%d</span><span class="s2"> local seq </span><span class="si">%d</span><span class="s2"> attempt </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="o">.</span><span class="n">format_args</span> <span class="o">=</span> <span class="s2">&quot;i4i4i4&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">struct</span> <span class="p">{</span> <span class="n">u32</span> <span class="n">stream_id</span><span class="p">,</span> <span class="n">local_sequence</span><span class="p">,</span> <span class="n">retry_count</span><span class="p">;</span> <span class="p">}</span> <span class="o">*</span> <span class="n">ed</span><span class="p">;</span>
<span class="n">ed</span> <span class="o">=</span> <span class="n">ELOG_DATA</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">elog_main</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
<span class="n">ed</span><span class="o">-&gt;</span><span class="n">stream_id</span> <span class="o">=</span> <span class="n">stream_id</span><span class="p">;</span>
<span class="n">ed</span><span class="o">-&gt;</span><span class="n">local_sequence</span> <span class="o">=</span> <span class="n">local_sequence</span><span class="p">;</span>
<span class="n">ed</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="n">retry_count</span><span class="p">;</span>
</pre></div>
</div>
<p>The ELOG_DATA macro returns a pointer to 20 bytes worth of arbitrary
event data, to be formatted (offline, not at runtime) as described by
format_args. Aside from obvious integer formats, the CLIB event logger
provides a couple of interesting additions. The “t4” format
pretty-prints enumerated values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ELOG_TYPE_DECLARE</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s2">&quot;get_or_create: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
  <span class="o">.</span><span class="n">format_args</span> <span class="o">=</span> <span class="s2">&quot;t4&quot;</span><span class="p">,</span>
  <span class="o">.</span><span class="n">n_enum_strings</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="o">.</span><span class="n">enum_strings</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;old&quot;</span><span class="p">,</span> <span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The “t” format specifier indicates that the corresponding datum is an
index in the event’s set of enumerated strings, as shown in the
previous event type definition.</p>
<p>The “T” format specifier indicates that the corresponding datum is an
index in the event log’s string heap. This allows the programmer to
emit arbitrary formatted strings. One often combines this facility
with a hash table to keep the event-log string heap from growing
arbitrarily large.</p>
<p>Noting the 20-octet limit per-log-entry data field, the event log
formatter supports arbitrary combinations of these data types. As in:
the “.format” field may contain one or more instances of the
following:</p>
<ul class="simple">
<li>i1 - 8-bit unsigned integer</li>
<li>i2 - 16-bit unsigned integer</li>
<li>i4 - 32-bit unsigned integer</li>
<li>i8 - 64-bit unsigned integer</li>
<li>f4 - float</li>
<li>f8 - double</li>
<li>s - NULL-terminated string - be careful</li>
<li>sN - N-byte character array</li>
<li>t1,2,4 - per-event enumeration ID</li>
<li>T4 - Event-log string table offset</li>
</ul>
<p>The vpp engine event log is thread-safe, and is shared by all
threads. Take care not to serialize the computation. Although the
event-logger is about as fast as practicable, it’s not appropriate for
per-packet use in hard-core data plane code. It’s most appropriate for
capturing rare events - link up-down events, specific control-plane
events and so forth.</p>
<p>The vpp engine has several debug CLI commands for manipulating its event log:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vpp</span><span class="c1"># event-logger clear</span>
<span class="n">vpp</span><span class="c1"># event-logger save &lt;filename&gt; # for security, writes into /tmp/&lt;filename&gt;.</span>
                                  <span class="c1"># &lt;filename&gt; must not contain &#39;.&#39; or &#39;/&#39; characters</span>
<span class="n">vpp</span><span class="c1"># show event-logger [all] [&lt;nnn&gt;] # display the event log</span>
                                   <span class="c1"># by default, the last 250 entries</span>
</pre></div>
</div>
<p>The event log defaults to 128K entries. The command-line argument
“… vlib { elog-events &lt;nnn&gt; }” configures the size of the event log.</p>
<p>As described above, the vpp engine event log is thread-safe and
shared. To avoid confusing non-appearance of events logged by worker
threads, make sure to code &amp;vlib_global_main.elog_main - instead of
&amp;vm-&gt;elog_main. The latter form is correct in the main thread, but
will almost certainly produce bad results in worker threads.
Vlib, Vlibapi, Vlibmemory
===================</p>
<p>Vlib and associated libraries (vlibapi, vlibmemory) provides vector processing support including graph-node
scheduling, reliable multicast support, ultra-lightweight cooperative
multi-tasking threads, a CLI, plug in .DLL support, physical memory and Linux epoll support. Parts of this library embody US Patent 7,961,636.</p>
</div>
<div class="section" id="g2-graphical-event-viewer">
<h4>G2 graphical event viewer<a class="headerlink" href="#g2-graphical-event-viewer" title="Permalink to this headline">¶</a></h4>
<p>The g2 graphical event viewer can display serialized vppinfra event
logs directly, or via the c2cpel tool.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Todo: please convert wiki page and figures</p>
</div>
</div>
<div class="section" id="init-function-discovery">
<h4>Init function discovery<a class="headerlink" href="#init-function-discovery" title="Permalink to this headline">¶</a></h4>
<p>vlib applications register for various [initialization] events by
placing structures and __attribute__((constructor)) functions into the
image. At appropriate times, the vlib framework walks
constructor-generated singly-linked structure lists, calling the
indicated functions. vlib applications create graph nodes, add CLI
functions, start cooperative multi-tasking threads, etc. etc. using
this mechanism.</p>
<p>vlib applications invariably include a number of VLIB_INIT_FUNCTION
(my_init_function) macros.</p>
<p>Each init / configure / etc. function has the return type clib_error_t
*. Make sure that the function returns 0 if all is well, otherwise
the framework will announce an error and exit.</p>
<p>vlib applications must link against vppinfra, and often link against
other libraries such as VNET. In the latter case, it may be necessary
to explicitly reference symbol(s) otherwise large portions of the
library may be AWOL at runtime.</p>
<div class="section" id="node-graph-initialization">
<h5>Node Graph Initialization<a class="headerlink" href="#node-graph-initialization" title="Permalink to this headline">¶</a></h5>
<p>vlib packet-processing applications invariably define a set of graph
nodes to process packets.</p>
<p>One constructs a vlib_node_registration_t, most often via the
VLIB_REGISTER_NODE macro. At runtime, the framework processes the set
of such registrations into a directed graph. It is easy enough to add
nodes to the graph at runtime. The framework does not support removing
nodes.</p>
<p>vlib provides several types of vector-processing graph nodes,
primarily to control framework dispatch behaviors. The type member of
the vlib_node_registration_t functions as follows:</p>
<ul class="simple">
<li>VLIB_NODE_TYPE_PRE_INPUT - run before all other node types</li>
<li>VLIB_NODE_TYPE_INPUT - run as often as possible, after pre_input nodes</li>
<li>VLIB_NODE_TYPE_INTERNAL - only when explicitly made runnable by adding pending frames for processing</li>
<li>VLIB_NODE_TYPE_PROCESS - only when explicitly made runnable. “Process” nodes are actually cooperative multi-tasking threads. They <strong>must</strong> explicitly suspend after a reasonably short period of time.</li>
</ul>
<p>For a precise understanding of the graph node dispatcher, please read
…/src/vlib/main.c:vlib_main_loop.</p>
</div>
<div class="section" id="graph-node-dispatcher">
<h5>Graph node dispatcher<a class="headerlink" href="#graph-node-dispatcher" title="Permalink to this headline">¶</a></h5>
<p>Vlib_main_loop() dispatches graph nodes. The basic vector processing
algorithm is diabolically simple, but may not be obvious from even a
long stare at the code. Here’s how it works: some input node, or
set of input nodes, produce a vector of work to process. The graph
node dispatcher pushes the work vector through the directed graph,
subdividing it as needed, until the original work vector has been
completely processed. At that point, the process recurs.</p>
<p>This scheme yields a stable equilibrium in frame size, by
construction. Here’s why: as the frame size increases, the
per-frame-element processing time decreases. There are several related
forces at work; the simplest to describe is the effect of vector
processing on the CPU L1 I-cache. The first frame element [packet]
processed by a given node warms up the node dispatch function in the
L1 I-cache. All subsequent frame elements profit. As we increase the
number of frame elements, the cost per element goes down.</p>
<p>Under light load, it is a crazy waste of CPU cycles to run the graph
node dispatcher flat-out. So, the graph node dispatcher arranges to
wait for work by sitting in a timed epoll wait if the prevailing frame
size is low. The scheme has a certain amount of hysteresis to avoid
constantly toggling back and forth between interrupt and polling
mode. Although the graph dispatcher supports interrupt and polling
modes, our current default device drivers do not.</p>
<p>The graph node scheduler uses a hierarchical timer wheel to reschedule
process nodes upon timer expiration.</p>
</div>
<div class="section" id="process-thread-model">
<h5>Process / thread model<a class="headerlink" href="#process-thread-model" title="Permalink to this headline">¶</a></h5>
<p>vlib provides an ultra-lightweight cooperative multi-tasking thread
model. The graph node scheduler invokes these processes in much the
same way as traditional vector-processing run-to-completion graph
nodes; plus-or-minus a setjmp/longjmp pair required to switch
stacks. Simply set the vlib_node_registration_t type field to
vlib_NODE_TYPE_PROCESS. Yes, process is a misnomer. These are
cooperative multi-tasking threads.</p>
<p>As of this writing, the default stack size is 2&lt;&lt;15; 32kb. Initialize
the node registration’s process_log2_n_stack_bytes member as
needed. The graph node dispatcher makes some effort to detect stack
overrun, e.g. by mapping a no-access page below each thread stack.</p>
<p>Process node dispatch functions are expected to be “while(1) { }” loops
which suspend when not otherwise occupied, and which must not run for
unreasonably long periods of time.</p>
<p>“Unreasonably long” is an application-dependent concept. Over the
years, we have constructed frame-size sensitive control-plane nodes
which will use a much higher fraction of the available CPU bandwidth
when the frame size is low. The classic example: modifying forwarding
tables. So long as the table-builder leaves the forwarding tables in a
valid state, one can suspend the table builder to avoid dropping
packets as a result of control-plane activity.</p>
<p>Process nodes can suspend for fixed amounts of time, or until another
entity signals an event, or both. See the next section for a
description of the vlib process event mechanism.</p>
<p>When running in vlib process context, one must pay strict attention to
loop invariant issues. If one walks a data structure and calls a
function which may suspend, one had best know by construction that it
cannot change. Often, it’s best to simply make a snapshot copy of a
data structure, walk the copy at leisure, then free the copy.</p>
</div>
<div class="section" id="process-events">
<h5>Process events???<a class="headerlink" href="#process-events" title="Permalink to this headline">¶</a></h5>
<p>The vlib process event mechanism API is extremely lightweight and easy
to use. Here is a typical example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vlib_main_t *vm = &amp;vlib_global_main;
uword event_type, * event_data = 0;

while (1)
{
   vlib_process_wait_for_event_or_clock (vm, 5.0 /* seconds */);

   event_type = vlib_process_get_events (vm, &amp;event_data);

   switch (event_type) {
   case EVENT1:
       handle_event1s (event_data);
       break;

   case EVENT2:
       handle_event2s (event_data);
       break;

   case ~0: /* 5-second idle/periodic */
       handle_idle ();
       break;

   default: /* bug! */
       ASSERT (0);
   }

   vec_reset_length(event_data);
}
</pre></div>
</div>
<p>In this example, the VLIB process node waits for an event to occur, or
for 5 seconds to elapse. The code demuxes on the event type, calling
the appropriate handler function. Each call to vlib_process_get_events
returns a vector of per-event-type data passed to successive
vlib_process_signal_event calls; vec_len (event_data) &gt;= 1.</p>
<p>It is an error to process only event_data[0].</p>
<p>Resetting the event_data vector-length to 0 [instead of calling
vec_free] means that the event scheme doesn’t burn cycles continuously
allocating and freeing the event data vector. This is a common
vppinfra / vlib coding pattern, well worth using when appropriate.</p>
<p>Signaling an event is easy, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vlib_process_signal_event</span> <span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">process_node_index</span><span class="p">,</span> <span class="n">EVENT1</span><span class="p">,</span>
    <span class="p">(</span><span class="n">uword</span><span class="p">)</span><span class="n">arbitrary_event1_data</span><span class="p">);</span> <span class="o">/*</span> <span class="ow">and</span> <span class="n">so</span> <span class="n">forth</span> <span class="o">*/</span>
</pre></div>
</div>
<p>One can either know the process node index by construction - dig it
out of the appropriate vlib_node_registration_t - or by finding the
vlib_node_t with vlib_get_node_by_name(…).</p>
</div>
<div class="section" id="buffers">
<h5>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h5>
<p>vlib buffering solves the usual set of packet-processing problems,
albeit at high performance. Key in terms of performance: one
ordinarily allocates / frees N buffers at a time rather than one at a
time. Except when operating directly on a specific buffer, one deals
with buffers by index, not by pointer.</p>
<p>Packet-processing frames are effectively u32[], not
vlib_buffer_t[].</p>
<p>Packets comprise one or more vlib buffers, chained together as
required. Multiple particle sizes are supported; hardware input nodes
simply ask for the required size(s). Coalescing support is
available. For obvious reasons one is discouraged from writing one’s
own wild and wacky buffer chain traversal code.</p>
<p>vlib buffer headers are allocated immediately prior to the buffer data
area. In typical packet processing this saves a dependent read wait:
given a buffer’s address, one can prefetch the buffer header
[metadata] at the same time as the first cache line of buffer data.</p>
<p>Buffer header metadata (vlib_buffer_t) includes the usual rewrite
expansion space, a current_data offset, RX and TX interface indices,
packet trace information, and a opaque areas.</p>
<p>The opaque data is intended to control packet processing in arbitrary
subgraph-dependent ways. The programmer shoulders responsibility for
data lifetime analysis, type-checking, etc.</p>
<p>Buffers have reference-counts in support of e.g. multicast
replication.</p>
</div>
<div class="section" id="shared-memory-message-api">
<h5>Shared-memory message API<a class="headerlink" href="#shared-memory-message-api" title="Permalink to this headline">¶</a></h5>
<p>Local control-plane and application processes interact with the vpp
dataplane via asynchronous message-passing in shared memory over
unidirectional queues. The same application APIs are available via
sockets.</p>
<p>Capturing API traces and replaying them in a
simulation environment requires a disciplined approach
to the problem. This seems like a make-work task, but it is not. When
something goes wrong in the control-plane after 300,000 or 3,000,000
operations, high-speed replay of the events leading up to the accident
is a huge win.</p>
<p>The shared-memory message API message allocator vl_api_msg_alloc uses
a particularly cute trick. Since messages are processed in order, we
try to allocate message buffering from a set of fixed-size,
preallocated rings. Each ring item has a “busy” bit. Freeing one of
the preallocated message buffers merely requires the message consumer
to clear the busy bit. No locking required.</p>
<p>SVM
SVM performs the shared VM allocation, defines the mmap page size, and works with the mapping.</p>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Network_Stack_Layer.html" class="btn btn-neutral float-right" title="Network Stack Layer (src/vnet)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, John DeNisco.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>